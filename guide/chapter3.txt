Chapter 3 - FAQ
===============

!include "guide/menu.inc"

Table of Contents
-----------------
* [1 Where do I go for help?](#q1)
* [2 What is Libmarpa?](#q2)
* [3 Is Marpa deterministic?](#q3)
* [4 Why doesn't my ambiguous grammar return more than 1 parse tree?](#q4)
* [5 How do I implement disambiguation logic?](#q5)
* [6 Why did I get: Parse failed. value() called when recognizer is not in tree mode\nThe current mode is "forest"](#q6)
* [7 What is the meaning of L0 and G1?](#q7)
* [8 How do I parse comments?](#q8)
* [9 How do I parse numbers?](#q9)
* [10 How do I represent choice in the grammar?](#q10)
* [11 Is there any other way of representing choice?](#q11)
* [12 What's the difference between '|' and '||' in grammar definitions?](#q12)
* [13 What does it mean to hide (mask) tokens?](#q13)
* [14 How do I implement recursion in a grammar?](#q14)
* [15 Why does using '+' or '*' in a rule only work sometimes?](#q15)
* [16 Can a lexeme have length == 0?](#q16)
* [17 How do I find out where I am within the input stream?](#q17)
* [18 How do I find out which rule applies at some point in the input stream (e.g. during a pause)?](#q18)
* [19 What is the meaning of the line number in a Marpa error message?](#q19)
* [20 Can I switch grammars during a parse?](#q20)
* [21 Where is Ruby Slippers parsing documented?](#q21)
* [22 Where can I find code using Ruby Slippers?](#q22)
* [23 How do I associate an action class with my grammar?](#q23)
* [24 Declaring an Action Class](#q24)
* [25 Where can I find code using events?](#q25)
* [26 Where can I find code which builds its grammar on-the-fly?](#q26)
* [27 Other Resources](#q27)

<a name="q1"></a>
1 Where do I go for help?
-------------------------
The IRC channel may get the quickest response: irc.freenode.net#marpa.

[The Google Group](https://groups.google.com/forum/#!forum/marpa-parser) has message threading,
and so is good for complex or extended discussions.

[Marpa's homepage](http://savage.net.au/Marpa.html).

<a name="q2"></a>
2 What is Libmarpa?
-------------------
Libmarpa is the core Marpa library, written in C, which implements the Marpa parse engine - the Marpa algorithm itself.
It is low-level, but it is documented and can be installed and used separately.

[Homepage](https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html).

[Formal docs](https://jeffreykegler.github.io/Marpa-web-site/libmarpa_api/cpan_indexed/index.html).

<a name="q3"></a>
3 Is Marpa deterministic?
-------------------------
No. Marpa is non-deterministic, unlike traditional parsers. Marpa tries everything, all at once.

This may take some getting used to, in the sense that probably what you're used to is a deterministic parse.

If two alternatives (in a prioritized rule say, separated by '|' or '||') happen to match some source,
Marpa produces 2 parse trees.

The parser, then, catches all ambiguities, but the SLIF lexer does *not*, whether it is LTM or LATM.
LTM is Longest Token Match, and LATM is Longest Acceptable Token Match.

The SLIF lexer does a longest tokens (plural) match. So it does recognize ambiguous tokens if they are longest tokens.

Ambiguous tokens which are shorter than the match one (whether the discipline is "forgiving" or not) are ignored
by the lexer.

Consequently, this means the ambiguous matched tokens must be all the same length.

See also the next question.

<a name="q4"></a>
4 Why doesn't my ambiguous grammar return more than 1 parse tree?
-----------------------------------------------------------------
Probably because your grammar includes

	lexeme default = latm => 1 # Active the Longest Acceptable Token Match option.

Try commenting that line out after, perhaps, re-reading the previous question's answer.

See also the next 2 questions.

<a name="q5"></a>
5 How do I implement disambiguation logic?
------------------------------------------
See under [Bailing-out-of-parse-evaluation in Marpa::R2::Semantics](https://metacpan.org/module/Marpa::R2::Semantics#Bailing-out-of-parse-evaluation),
for how to short-circuit semantic analysis.

See also [this gist](https://gist.github.com/dginev/6419166).

See also the previous and next questions.

<a name="q6"></a>
6 Why did I get: Parse failed. value() called when recognizer is not in tree mode\nThe current mode is "forest"
---------------------------------------------------------------------------------------------------------------
The parse is ambiguous. Instead of getting a tree, you got multiple trees. Hence 'forest'.

See [this discussion of 'rank'](https://metacpan.org/pod/distribution/Marpa-R2/pod/Scanless/DSL.pod#rank).

Also see the long comment on rank at the start of sub BUILD in MarpaX::Languages::Perl::PackUnpack
[here](https://metacpan.org/source/RSAVAGE/MarpaX-Languages-Perl-PackUnpack-1.00/lib/MarpaX/Languages/Perl/PackUnpack.pm#L139).

See also the previous 2 questions.

<a name="q7"></a>
7 What is the meaning of L0 and G1?
-----------------------------------
L0 defines exactly what tokens are acceptable in the input stream. So, these are the rules defining the
syntax of the tokens, but not the syntax of how these tokens can be combined.

G1 defines the structure of the language. These rules define legal statements within the given language.
Legal statements are thus legal combinations of tokens.

The idea is that G1 is structural, and grammars are in the Ln series are lexers. ("L" for lexer.)

Also, G1 rules have a semantics, whereas L0 rules do not.

L0 and G1 discussed in [Marpa::R2::Scanless::DSL](https://metacpan.org/module/Marpa::R2::Scanless::DSL), and, very
briefly, in [Marpa::R2::Semantics](https://metacpan.org/module/Marpa::R2::Semantics). In both cases, search for 'L0'.

<a name="q8"></a>
8 How do I parse comments?
--------------------------

[GraphViz2::Marpa](https://metacpan.org/module/GraphViz2::Marpa) implements comment skipping for C
and C++ comments, and for #-prefix style comments. Search the source of Marpa.pm for
'C style comment', 'Cplusplus style comment' and 'hash style comment'.

<a name="q9"></a>
9 How do I parse numbers?
-------------------------
Chapter 2 of [Peter Stuifzand's Marpa Guide](http://marpa-guide.github.io/) discusses this issue at length
And if you fork that project on github, you'll find the directory examples/ contains about a dozen sample programs.

Alternately, download [MarpaX::Languages::SVG::Parser](https://metacpan.org/release/MarpaX-Languages-SVG-Parser),
which contains similar logic (in data/*.bnf). Further, this latter distro includes sample code (float.pl and number.pl)
in the scripts/ directory. The last-named script includes grammars for binary, octal and hex numbers which I did
not need in the SVG parser.

<a name="q10"></a>
10 How do I represent choice in the grammar?
--------------------------------------------
Briefly, use '|'. Sample code from the above named module (data/d.bnf):

	coordinate  ::= float      action => float
	                | integer  action => integer

Also note that '||' is available to control the relative priorities of the alternatives.

This issue is expanded upon in the next 2 items in this FAQ.

<a name="q11"></a>
11 Is there any other way of representing choice?
-------------------------------------------------
Sure. Consider these L0 rules (also from data/d.bnf):

	sign_maybe  ~ [+-]
	sign_maybe  ~

	digit       ~ [0-9]
	digit_any   ~ digit*
	digit_many  ~ digit+

	E           ~ [Ee] sign_maybe digit_many
	E_maybe     ~ E
	E_maybe     ~

	:lexeme     ~ float
	float       ~ sign_maybe digit_many E
	              | sign_maybe digit_any '.' digit_many E_maybe
	              | sign_maybe digit_many '.' E_maybe
	              | sign_maybe non_zero digit_any

This is saying:

* The sign is optional after E or e (sign_maybe)

* The E is optional (E_maybe)

* The sign is optional before a digit (the first alternative for 'float')

* And so on

<a name="q12"></a>
12 What's the difference between '|' and '||' in grammar definitions?
---------------------------------------------------------------------
'|' expresses a simple alternative, while '||' separates alternatives at different levels of precedence. For example:

	E ::=    E '*' E
	      |  E '/' E
	      || E '+' E
	      |  E '-' E

This describes syntax for a simple 4-operation calculator, where multiplication and division take precedence over
addition and subtraction.

This construct forces alternatives before the '||' to have higher precedence than the alternatives after that token.

Each of the alternatives separated by '|' are at the same precedence.

In Mark Dominus's 'Higher-Order Perl' book, he describes how he handles precedence in his recursive descent parsers
for a similar calculator, beginning on p. 394. This is a good description of how the same situation would be handled
with pre-Marpa techniques.

If precedence is not an issue for you, just use single bar alternation ('|').

Note also that Marpa supports a 'priority' adverb, discussed in the
[Marpa::R2::Scanless::DSL](https://metacpan.org/module/Marpa::R2::Scanless::DSL) docs mentioned above.

<a name="q13"></a>
13 What does it mean to hide (mask) tokens?
--------------------------------------------
It's possible to design a grammar such that we can say certain tokens are hidden. This is discussed under
[RHS-alternatives in Marpa::R2::Scanless::DSL](https://metacpan.org/module/Marpa::R2::Scanless::DSL#RHS-alternatives).

Here is an example (from [Graph::Easy::Marpa::Parser](https://metacpan.org/module/Graph::Easy::Marpa::Parser)):

	node_definition  ::= node_statement
	                 | node_statement graph_definition

	node_statement   ::= node_name
	                 | node_name attribute_definition
	                 | node_statement (',') node_statement

	node_name        ::= start_node end_node

	:lexeme          ~ start_node  pause => before  event => start_node
	start_node       ~ '['

	:lexeme          ~ end_node
	end_node         ~ ']'

The comma is hidden. But what does this mean, exactly?

It means the comma may appear in the input stream (in this context), but I am not interested in it. So, Marpa will not
return this token to me when an action is called. It has become invisible to the semantics.

Semantics are documented in [Marpa::R2::Semantics](https://metacpan.org/module/Marpa::R2::Semantics).

Close study of the above grammar will show that another path is possible thru the grammar, in the case of
2 nodes side-by-side (i.e. without a comma between them). Thus the grammar accepts both these input streams
as valid:

	Stream 1: [node.a], [node.b]
	Stream 2: [node.a]  [node.b]

Hence, from the end-user's viewpoint, the comma is defined - at least in this particular grammar - to be optional.

<a name="q14"></a>
14 How do I implement recursion in a grammar?
---------------------------------------------
See the next item.

<a name="q15"></a>
15 Why does using '+' or '*' in a rule only work sometimes?
-----------------------------------------------------------
I assume you're referring to cases like this:

Case 1 (fails):

	node_definition  ::= node_statement+
	                 | node_statement graph_definition

Case 2 (succeeds):

	coordinate_list  ::= coordinate+

Case 3 (succeeds):

	whitespace       ~ [\s]+

Briefly, quantified rules (here, using the '+'), are only allowed when the right-hand side contains a single
alternative. Thus case 1 fails due to the combination of '+' and '|'.

This is documented under [#Quantified-rules in Marpa::R2::Scanless::DSL](https://metacpan.org/module/Marpa::R2::Scanless::DSL#Quantified-rules).

So we must re-write rule 1 (with some context):

	graph_definition  ::= node_definition
	                  | edge_definition
	                  | subgraph_definition

	node_definition  ::= node_statement
	                 | node_statement graph_definition

	node_statement   ::= node_name
	                 | node_name attribute_definition
	                 | node_statement (',') node_statement

Now the rule 'node_definition ::= node_statement' allows a node definition to consist of a single node statement.

And the alternative (via the '|') 'node_definition ::= node_statement graph_definition' allows a node
definition to consist of a node statement followed by a graph definition, which just happens to include the line
'graph_definition ::= node_definition'!

So we've managed to write the grammar using indirect recursion, thus allowing an indefinite list of node
definitions to follow one another. And the last rule allows the input stream to separate them with commas as
well as the usual spaces.

In other words: Why does the SLIF require quantifiers to be separate statements?

It's different from regular expressions, which everyone is accustomed to, and seems awkward.

The reason is that, with a parser, you expect to attach a semantics to all the rules -
with regular expressions where is no such expectation.

So if Marpa allowed " A ::= B+ (C | D) exp*", how would you specify how the arguments are
passed to the semantics?

If just as a list, they have to be re-parsed all over again.

This problem can be solved, but the easiest way around it is to write it out as separate
statements, with the quantifiers by themselves, and the semantics can then be attached to
the statements.

<a name="q16"></a>
16 Can a lexeme have length == 0?
---------------------------------
No.

Marpa allows L0 rules that might be zero-length (for example, "baZ ~ [Z]*") on the idea that it might be convenient
to write them that way. But no zero-length lexeme will ever be accepted as a result of such rules.

If you think out the conceptual issues, you might see nulled lexemes are "fraught" with them. At any given point,
which null lexemes should you recognize? And how many of them? A parser could guess what you really mean here, but
to my (Jeffrey's) mind it is just as well to force you to be explicit on this issue.

Note: I (Ron) think Jeffrey uses pseudo in the name 'nulled pseudo-lexeme' because, being effectively of 0 length,
they can't actually be lexemes.

For sample code which shows a way of handling such an issue see
[null.lexeme.demo.pl](http://savage.net.au/Perl-modules/html/marpa.papers/null.lexeme.demo.pl) and
[null.lexeme.demo.1.pl](http://savage.net.au/Perl-modules/html/marpa.papers/null.lexeme.demo.1.pl).

<a name="q17"></a>
17 How do I find out where I am within the input stream?
--------------------------------------------------------
See [the line_column() method in Marpa::R2::Scanless::R](https://metacpan.org/module/Marpa::R2::Scanless::R#line_column()).

<a name="q18"></a>
18 How do I find out which rule applies at some point in the input stream (e.g. during a pause)?
------------------------------------------------------------------------------------------------
See under [Action-context in Marpa::R2::Semantics](https://metacpan.org/module/Marpa::R2::Semantics#Action-context),
for access to internal variables in Marpa which do what you want.

<a name="q19"></a>
19 What is the meaning of the line number in a Marpa error message?
-------------------------------------------------------------------
It is the line number within the BNF of the rule being processed.

Note: If your grammar uses \r, that will affect the line count.

Further, see [the line_column() method in Marpa::R2::Scanless::R](https://metacpan.org/module/Marpa::R2::Scanless::R#line_column())
for various special characters some of which may affect this line count.

<a name="q20"></a>
20 Can I switch grammars during a parse?
----------------------------------------

No - You can't just change Marpa's grammar object during a parse (by calling
Marpa::R2::Scanless::G -> new() with a new BNF), and expect everything else to keep working.

Nevertheless, there are techniques which can probably do what you want.

* 1: Combine the grammars

* 2: Use 'parse before' and switch grammars twice

* 3: Use an action, change the grammar, and re-parse

In a bit more detail:

1: 'Combine the grammars': Perhaps you are convinced this can't be done, but you are urged to try
it. Focus on the problem of defining the lexemes.

You may find your solution involves switching lexers rather than switching grammars.

2: 'Use parse before and switch grammars twice': This technique is used in
[GraphViz2::Marpa](https://metacpan.org/module/GraphViz2::Marpa).

The idea is to pause at the start of a substring you want to parse using a different grammar. Then,
parse just that substring using a different grammar object and a different recognizer object.

At the end of the substring, tell the first grammar to resume at the first character after the end
of the substring.

This works in my (Ron's) code because the second grammar ends with a known, matching, delimiter.
When Marpa encounters the next character, it generates the infamous error: "Parsing complete
but lexemes remain". Luckily for me, this just means there is (and there must be) tokens in the
input stream after the end of the substring which needed to be parsed using the second grammar. So
it's just a matter of asking Marpa if that particular error arose, processing the output from using
the second grammar, and returning to the parse which is using first grammar.

In the code referenced, search for '$self -> grammar' and '$self -> grammar4html'.

Your problem will obviously be: What happens at the end of the substring? I.e. How do you know it's
time to switch back to the previous grammar?

Also, this approach creates the problem of having the semantics defined in 2 different places. So
combining them may add complexity to your code.

3: 'Use an action, change the grammar, and re-parse': This technique is used in
[MarpaX::Languages::SQL2003::AST](https://github.com/jddurand/MarpaX-Languages-SQL2003-AST/blob/master/lib/MarpaX/Languages/SQL2003/AST/Actions.pm).

See [this IRC backlog entry](http://irclog.perlgeek.de/marpa/2014-12-12#i_9797844) for a discussion
by the author, Jean-Damien Durand, for why he does things this way.

Briefly, the parse of a substring (call it 'a') requires knowledge of what follows that substring
(call the second substring 'b'). So, parse it all ('a + b'), and when the action is triggered for
'b', use the information found to change the grammar used to parse 'a', and re-parse 'a'.

The effect (in Jean-Damien's case at least) is to use the result of a sub-grammar as a token value.

You may safely assume this latter method is a very advanced technique!

<a name="q21"></a>
21 Where is Ruby Slippers parsing documented?
---------------------------------------------
Start with [Marpa::R2::Semantics](https://metacpan.org/module/Marpa::R2::Recognizer#Ruby-Slippers-parsing).
This document has several references to Ruby Slippers.

See also Jeffrey's articles: [Ruby Slippers parsing](http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2011/11/marpa-and-the-ruby-slippers.html),
and the series beginning with [parsing HTML part 1](https://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2011/11/how-to-parse-html.html).

<a name="q22"></a>
22 Where can I find code using Ruby Slippers?
---------------------------------------------
See the script scripts/match.parentheses.02.pl, which ships with the module
[MarpaX::Demo::SampleScripts](https://metacpan.org/module/MarpaX::Demo::SampleScripts).

<a name="q23"></a>
23 How do I associate an action class with my grammar?
------------------------------------------------------

This discussion assumes you're using Marpa::R2 V 3.0 or later. Prior to that, there was complications
using the per-parse parameter to value(), and elsewhere.

See also: The next FAQ item, 'Declaring an Action Class'.

References:

1: [The per-parse argument to value()](https://metacpan.org/pod/distribution/Marpa-R2/pod/Semantics.pod#The-per-parse-argument)

2: [The per-parse constructor](https://metacpan.org/pod/distribution/Marpa-R2/pod/Semantics.pod#The-per-parse-constructor)

3: [Calling value(...)](https://metacpan.org/pod/distribution/Marpa-R2/pod/Scanless/R.pod#value)

Here's how I declare a recognizer in one package:

	$self -> recce
	(
		Marpa::R2::Scanless::R -> new
		({
			grammar           => $self -> grammar,
			semantics_package => 'MarpaX::Languages::SVG::Parser::Actions',
		})
	);

Now actions referenced in the grammar, as in:

	coordinate  ::= float      action => float
	                | integer  action => integer

must be declared as functions in the named semantics package, because that's where Marpa looks for them.

<a name="q24"></a>
24 Declaring an Action Class
----------------------------
The previous item in this FAQ discussed at length various issues regarding how to cleanly generate data within action
subs, and how to pass that data back to the main-line code which called Marpa.

Here I explain the standard solution as used in a module,
[MarpaX::Languages::SVG::Parser](https://metacpan.org/release/MarpaX-Languages-SVG-Parser), on CPAN. Briefly:

* Each action sub returns a _hashref_ to Marpa

This is because Marpa is the one calling the subs and gathering the results. And the hashrefs of course suit my code,
whereas you may prefer to use a different data structure.

* After a successful parse, the result of the parse is processed to recover those hashrefs

This result is returned by the value() method of the recognizer class.
See [value() in Marpa::R2::Scanless::R](https://metacpan.org/module/Marpa::R2::Scanless::R#value()).

There is one basic problem to solve along the way: The data structure Marpa makes available as the result of the parse
can be a deeply nested set of _arrayrefs_, depending on how deeply within the grammar the action sub is named.

So, we have to unravel the _arrayrefs_ to recover the _hashrefs_.

Conside this fragment of the SVG grammar from
[MarpaX::Languages::SVG::Parser](https://metacpan.org/release/MarpaX-Languages-SVG-Parser):

	curve_to			::= Cc curve_to_arguments  action => command

	curve_to_arguments	::= coordinate_triple
	                        | coordinate_triple curve_to_arguments
	...
	coordinate_triple	::= coordinate coordinate coordinate
	...
	coordinate			::= float  action => float
	...
	Cc                  ~ [Cc]

Thus, given a curve - say the string 'C 10,11 20,21 30,31' - Marpa will call both _float()_ and _command()_.

(Elsewhere the grammar says commas are to be discarded).

What happens in practice? Firstly, the code:

	sub command
	{
		my($hashref, $t1, @t2) = @_;
		$param_count = 0;

		return
		{
			count => ++$item_count,
			name  => $t1,
			type  => 'command',
			value => [@t2],
		};

	} # End of command.

	# -----------------

	sub float
	{
		my($hashref, $t1) = @_;

		return
		{
			count => ++$item_count,
			name  => ++$param_count,
			type  => 'float',
			value => $t1,
		};

	} # End of float.

Things to note:

* We don't count the floats, to ensure there are 6, or 8, ...

This is because the input stream is deemed to have been validatated as being SVG.

* A global variable counts output hashrefs

* A global variable counts parameters per command

* _float()_ is called for every number

This includes the fact that the grammar says there are at least 3 coordinates (float pairs) per _curve_ command.

This is not a problem, just a fact. We handle it with a Perl array, as explained next.

* _command()_ is called at the end of the string

Again, this is not a problem. On the contrary - it is an inescapable part of the solution!

But it does mean that we need to be aware of what Marpa does with the results of calling _float()_, i.e. where
are they, when Marpa calls _command()_.

It is simple. The results of the 6+ (in this grammar) calls to _float()_, 6+ _hashrefs_, are passed as the trailing
parameters in the call to 	_command()_. That explains the @t2 parameter in the first line of _command()_.

Likewise, we can say that since, in the grammar, nothing is subservient to _float_, then no action subs can possibly
be called in the processing of a float. So, when _float()_ is called, it _cannot have_ any such trailing parameters.

Where does this leave us? It means that the @t2 parameter to _command()_ contains a set of 6+ floats packaged as
_hahsrefs_ inside an unknown number of _arrayrefs_.

The same logic applies to the output of _command()_ within the context of the output of parsing the whole input stream.

Our final task then will be to recover the result of the parse and unravel and discard the _arrayrefs_. This will
leave us with a set of _hashrefs_, which was the point of the exercise. I should repeat: This structure suits my
purpose. Adapt as required.

The remainder of the code:

	my($result) = $self -> recce -> value;

	die "Marpa's parse failed\n" if (! defined $result);

	# Unravel whatever Marpa gives us.

	for my $item (@{$self -> decode_result($$result)})
	{
		# If it's a command, unravel the 'value => [@t2]' component.

		if ($$item{type} eq 'command')
		{
			$self -> new_item($$item{type}, $$item{name}, '-');

			for my $param (@{$self -> decode_result($$item{value})})
			{
				$self -> new_item($$param{type}, $$param{name}, $$param{value});
			}
		}
		else
		{
			$self -> new_item($$item{type}, $$item{name}, $$item{value});
		}
	}

Lastly, the workhorse sub:

	sub decode_result
	{
		my($self, $result) = @_;
		my(@worklist) = $result;

		my($obj);
		my($ref_type);
		my(@stack);

		do
		{
			$obj      = shift @worklist;
			$ref_type = ref $obj;

			if ($ref_type eq 'ARRAY')
			{
				unshift @worklist, @$obj; # Unravel Marpa's handiwork.
			}
			elsif ($ref_type eq 'HASH')
			{
				push @stack, {%$obj}; # Build array of results.
			}
			else
			{
				die "Unsupported object type $ref_type\n" if ($ref_type);
			}
		} while (@worklist);

		return [@stack]; # Return an arrayref of hashrefs.

	} # End of decode_result.

I must acknowledge the work done by the authors of [Data::Find](https://metacpan.org/release/Data-Find),
[Data::Recursive::Encode](https://metacpan.org/release/Data-Recursive-Encode) and
[MarpaX::Languages::C::AST](https://metacpan.org/release/MarpaX-Languages-C-AST 'In *::Util::Data::Find').
They all use similar mechanisms for unravelling data structures.

<a name="q25"></a>
25 Where can I find code using events?
--------------------------------------
The are many Perl modules which use events.

Try [MarpaX::Languages::Perl::PackUnpack](https://metacpan.org/release/MarpaX-Languages-Perl-PackUnpack)
or [GraphViz2::Marpa](https://metacpan.org/release/MarpaX-Languages-Perl-PackUnpack).

<a name="q26"></a>
26 Where can I find code which builds its grammar on-the-fly?
-------------------------------------------------------------
A simple case: [Text::Balanced::Marpa](https://metacpan.org/release/Text-Balanced-Marpa).

A complex case: [MarpaX::Languages::SQL2003::AST](https://metacpan.org/release/MarpaX-Languages-SQL2003-AST).

<a name="q27"></a>
27 Other Resources
------------------
* http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html

* The list of features in [Chapter 2 - Marpa's Advantages](chapter2.html)

!include "guide/menu.inc"

